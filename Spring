Q: When do we go with Setter and Constructor Injection, pros and cons
A: Difference 
# constructor based injection: 
1) It can be used when object's dependencies are not optional and they must be initialized with their dependencies
2) It can be used if the order of initialization or dependency matters
# Property based injection:
1) when dependencies are optional
2) if the order of initialization or dependency doesn't matters

Q: Spring Security Example: Limit Number of User Session
XML Configuration:
<session-management invalid-session-url="/logout.html">
    <concurrency-control max-sessions="1" error-if-maximum-exceeded="true" />
</session-management>
Java configuration

Q: Spring security Example: Session timeout
XML Configuration:
<session-config>
    <session-timeout>15</session-timeout>
    <tracking-mode>COOKIE</tracking-mode>
</session-config>

Java configuration

Q: Role of DispatcherServlet and ContextLoaderListener
DispatcherServlet is basically the front controller in the Spring MVC application as it loads the spring bean configuration file 
and initializes all the beans that have been configured. If annotations are enabled, it also scans the packages to configure any bean 
annotated with @Component, @Controller, @Repository or @Service annotations.

ContextLoaderListener, on the other hand, is the listener to start up and shut down the WebApplicationContext in Spring root. 
Some of its important functions includes tying up the lifecycle of ApplicationContext to the lifecycle of the ServletContext and 
automating the creation of ApplicationContext.

Q: uses of the JDBC template in Spring
The Spring JDBC template automatically cleans up the resources; like releasing database connections.
The Spring JDBC template converts the standard JDBC SQLExceptions into RuntimeExceptions. 
This ensures faster response time to identify and eliminate errors.

Q: Different types of autowiring:
Desc: automatic dependency injection. Autowiring can't be used to inject primitive and string values. It works with reference only.
Types:
none(Default)
autowirebyName:  Auto wiring by property name. If the name of a bean is same as the name of other bean property, auto wire it.
autowirebyType: Auto wiring by property data type. If data type of a bean is compatible with the data type of other bean property, auto wire it.
autowire by constructor: byType mode in constructor argument.
autowire with @Autowired and @Qualifier annotations

Q: Transactions:
Making multiple SP calls transactional
@Transactional(rollbackFor=Exception.class)
public void performBothSProcsTransactionally(){
   //executeSP1
   //executeSP2
}

#ACID
Atomicity − A transaction should be treated as a single unit of operation, which means either the entire sequence of operations is successful or unsuccessful.
Consistency − This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.
Isolation − There may be many transaction processing with the same data set at the same time. Each transaction should be isolated from others to prevent data corruption.
Durability − Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure.

Link: https://dzone.com/articles/spring-transaction-management

#Isolation: 
@Transactional (isolation=Isolation.READ_COMMITTED)'
The default is Isolation.DEFAULT
Most of the times, we will use default unless and until you have specific requirements.
Informs the transaction (tx) manager that the following isolation level should be used for the current tx. Should be set at the point from where the tx starts because we cannot change the isolation level after starting a tx.

DEFAULT: Use the default isolation level of the underlying database.

READ_COMMITTED: A constant indicating that dirty reads are prevented; non-repeatable reads and phantom reads can occur.

READ_UNCOMMITTED: This isolation level states that a transaction may read data that is still uncommitted by other transactions.

REPEATABLE_READ: A constant indicating that dirty reads and non-repeatable reads are prevented; phantom reads can occur.

SERIALIZABLE: A constant indicating that dirty reads, non-repeatable reads, and phantom reads are prevented.

Dirty Reads: Transaction 'A' writes a record. Meanwhile Transaction 'B' reads that same record before Transaction A commits. Later Transaction A decides to rollback and now we have changes in Transaction B that are inconsistent. This is a dirty read. Transaction B was running in READ_UNCOMMITTED isolation level so it was able to read Transaction A changes before a commit occurred.
Non-Repeatable Reads: Transaction 'A' reads some record. Then Transaction 'B' writes that same  record and commits. Later Transaction A reads that same record again and may get different values because Transaction B made changes to that record and committed. This is a non-repeatable read.
Phantom Reads: Transaction 'A' reads a range of records. Meanwhile Transaction 'B' inserts a new record in the same range that Transaction A initially fetched and commits. Later Transaction A reads the same range again and will also get the record that Transaction B just inserted. This is a phantom read: a transaction fetched a range of records multiple times from the database and obtained different result sets (containing phantom records).

#Propogation:
@Transactional(propagation=Propagation.REQUIRED)
If not specified, the default propagational behavior is REQUIRED. 

Other options are REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER, and NESTED.

REQUIRED : Indicates that the target method can not run without an active tx. If a tx has already been started before the invocation of this method, then it will continue in the same tx or a new tx would begin soon as this method is called.    

REQUIRES_NEW: Indicates that a new tx has to start every time the target method is called. If already a tx is going on, it will be suspended before starting a new one.

MANDATORY: Indicates that the target method requires an active tx to be running. If a tx is not going on, it will fail by throwing an exception.

SUPPORTS: Indicates that the target method can execute irrespective of a tx. If a tx is running, it will participate in the same tx. If executed without a tx it will still execute if no errors.
Methods which fetch data are the best candidates for this option.

NOT_SUPPORTED: Indicates that the target method doesn’t require the transaction context to be propagated.
Mostly those methods which run in a transaction but perform in-memory operations are the best candidates for this option.

NEVER: Indicates that the target method will raise an exception if executed in a transactional process.
This option is mostly not used in projects.
